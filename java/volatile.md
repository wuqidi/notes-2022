##### volatile特性

* 保证可见性
* 不保证原子性
* 禁止指令重排

**保证可见性：**

JMM模型：java内存模型，规定了内存同步规定

 * 线程加锁前，必须读取主内存(堆)的最新值到工作内存(栈)

 * 线程解锁前，必须将共享变量的值刷新到主内存

   这里的加锁、解锁必须是同一把锁

例子：只有一台服务器的秒杀

​	a/b/c三个线程，剩余1件商品，abc都读取到了，并加载到了自己的工作内存；

​	假设cpu给了a线程资源，a线程将更新剩余0件商品，因为b、c的工作内存还是1呢，此时可以通过volatile进行数据的可见性，b、c的工作内存也变为0了。

**不保证原子性：**

​	有个操作 ```n++；```这个一行代码可以分解成三个cpu指令，如果线程a执行一半，线程b开始执行，这就是不保证原子性。(cas能保证原子性，同级目录下cas.md)

**禁止指令重排：**

为了提高性能，编译器或者cpu都会对指令进行优化处理。

源代码->编译器指令重排->指令并行重排->内存系统重排->最终执行指令

实现禁止指令重-->**内存屏障(内存栅栏)：**内存屏障是一个cpu指令

* 不会把后面的指令排到内存屏障之前，也不会把前面的指令排到内存屏障后面
* 强制对缓存的修改操作立即写入主内存
* 如果是写操作，会导致其他CPU中缓存无效

cpu的指令重排，是为了提高cpu性能，放松内存一致性的要求，这就导致了乱序的发生。不同cpu所选择的内存模型也不一样。

**cpu内存模型**

 * TSO模型：放松写-读的内存一致性要求，即可能优化成读-写。
 * PSO模型：放松写-读，并且放松了写-写，即两个写可能乱序。
	* RMO模型：读-读，写-写，读-写，写-读，四种操作都允许乱序。

| 内存模型 | TSO:X86 | PSO:sparc-pso | RMO:IA64 |
| -------- | ------- | ------------- | -------- |
| 写-读    | 乱序    | 乱序          | 乱序     |
| 写-写    | 不      | 乱序          | 乱序     |
| 读-读    | 不      | 不            | 乱序     |
| 读-写    | 不      | 不            | 乱序     |

写-读：引入了store buffer，写操作不会马上生效；如果写生效在读之后，即乱序。
写-写：若是store buffer，不是FIFO，则两个写操作可能乱序。
读-读：如果CPU有Invalidate Queue这样结构，第二个读之前，若没清除Invalidate Queue，则会读取到旧值。
读-写：阻塞？

##### java的内存屏障：

两个读、写操作之间加上内存屏障，LoadLoad Barriers/StoreStore Barriers/LoadStore Barriers/StoreLoad Barriers，加入内存屏障以后读、写就不能乱序执行。

**什么情况下会插入内存屏障？**

* volatile写操作后，其他cpu内存马上能读取到最新值；
* volatile读操作后，发生的非volatile读写操作不能优化到其之前
* volatile写操作前，发生的非volatile读写操作不能优化到其之后

*资料*

[(24条消息) 深入理解java内存屏障(volatile实现原理)_java伟大航路的博客-CSDN博客_java 内存屏障](https://blog.csdn.net/u013291050/article/details/117335477)