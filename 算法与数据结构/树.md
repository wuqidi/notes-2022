##### ![树](树.assets/image-20220516003926428.png)

节点高度：节点到叶子节点的最长路径->从叶子往根节点看，0开始
节点深度：根节点到该节点所经历边的个数->从根节点往叶子看，0开始
节点层数：节点深度+1->从1开始，1/2/3层
树的高度：根节点高度

#### 二叉树 

每个节点最多有两个子节点，可以有一个，或者没有。

**满二叉树**：每个节点都有两个子节点，不缺。
**完全二叉树**：最后一层的左子节点都不缺。完全二叉树是最节省内存的一种方式，堆就是一种完全二叉树。
**二叉查找树(二叉搜索树/二叉排序树)**：左子节点小于父节点，右子节点大于父节点。支持动态数据的快速插入、删除、查找。

##### **存储二叉树：**

* 基于指针的二叉链路存储：

  ![image-20220516005426122](树.assets/image-20220516005426122.png)

* 基于数组的顺序存储：![image-20220516010059050](树.assets/image-20220516010059050.png)
  root节点存储下标1的位置；左子节点=```2*i```的位置；右子节点=```2*i+1```位置；i为层数；i/2，i>1=父节点位置；

  * 如果不是完全二叉树会浪费很多空间![image-20220516010113717](树.assets/image-20220516010113717.png)

##### 遍历二叉树

* 前序遍历：先打印父节点，然后左子树，右子树

* 中序遍历：先打印左子树，父节点，右子树

* 后序遍历：先打印左子树，右子树，父节点

  每个节点最多会遍历两次，所以遍历的时间复杂度是O(n)

##### 遍历、插入、删除二叉查找树

![image-20220516012213722](树.assets/image-20220516012213722.png)

![image-20220516012329285](树.assets/image-20220516012329285.png)

![image-20220516012409974](树.assets/image-20220516012409974.png)

**中序遍历二叉查找树**：输出有序序列，时间复杂度O(n)

​	**支持重复数据的二叉查找树**：
​		方案1：把值相同的数据都存储在同一个节点上
​		方案2：如果值相同，将相同值的数据插入到该节点的右子树，作为右子树的左节点。即值相同，作为大于当前节点的值处理。查找、删除的时候，要遍历到叶子节点才行。

​	**二叉查找树操作时间复杂度分析：**
​	![image-20220516013521883](树.assets/image-20220516013521883.png)

左1：退化成链表了，时间复杂度是O(n)
右1：完全二叉树，时间复杂度是O(logN)

##### 二叉查找树与散列表：

​	散列表的操作可以达到O(1)，为什么还有二叉查找树？
 * 散列表无法有序输出

 * 散列表扩容耗时，而且遇到散列冲突时，性能不稳定。

 * 在数据量大的时候，散列表hash冲突的存在性，查找速度效率下降

   具体可参照JDK1.8中HashMap的存储实现方式

##### 平衡二叉查找树

​	









B树=平衡树=2-3-4树

平衡树主要用于查找使用，最坏的情况下查找能保持O(logN)的时间复杂度；一个不具备平衡性的树，可能会变成单链表，查找时间复杂度会到O(N)的时间复杂度。

